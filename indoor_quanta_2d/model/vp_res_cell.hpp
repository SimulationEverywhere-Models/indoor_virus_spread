/**
 * Copyright (c) 2020, Cristina Ruiz Martin
 * ARSLab - Carleton University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/**
* Model developed by Hoda Khalil in Cell-DEVS CD++
* Implemented in Cadmium-cell-DEVS by Cristina Ruiz Martin
*/

#ifndef CADMIUM_CELLDEVS_vp_CELL_HPP
#define CADMIUM_CELLDEVS_vp_CELL_HPP

#include <cmath>
#include <stdlib.h>
#include <nlohmann/json.hpp>
#include <cadmium/celldevs/cell/grid_cell.hpp>

using nlohmann::json;
using namespace cadmium::celldevs;
using namespace std;

/************************************/
/******COMPLEX STATE STRUCTURE*******/
/************************************/
enum CELL_TYPE {AIR=-100, vp_SOURCE=-200, IMPERMEABLE_STRUCTURE=-300, DOOR=-400, TABLE=-500, VENTILATION=-600, CHAIR=-700, vp_RECEIVER=-800};

struct vp_cell {
    int counter;
    bool edge;
    CELL_TYPE type;
    CELL_TYPE prev_type;
    int breathing_counter;
    int prev_num_particles;
    int num_particles;
    int neighbor_portion;
    int remainder;
    int flow_portion;
    int infection_threshold;
    int prev_inhaled_particles;
    int inhaled_particles;
    vector<int> direction;
    int time_stayed;

    vp_cell() : counter(-1), edge(false), prev_type(AIR), type(AIR), breathing_counter(20), prev_num_particles(0), num_particles(0), neighbor_portion(0), remainder(0), flow_portion(0), prev_inhaled_particles(0), inhaled_particles(0), infection_threshold(1000), direction({0,0}), time_stayed(1800) {}  // a default constructor is required
    vp_cell(int i_counter, CELL_TYPE i_type, int i_breathing_counter, int i_num_particles) : counter(i_counter), type(i_type), breathing_counter(i_breathing_counter), num_particles(i_num_particles) {}
    
};

// Required for comparing states and detect any change
inline bool operator != (const vp_cell &x, const vp_cell &y) {
	//note that breathing_counter is not included here intentionally as it is onlu used to add the breathing factor
    return (x.counter != y.counter || x.num_particles != y.num_particles || x.direction != y.direction || x.type != y.type || x.inhaled_particles != y.inhaled_particles);
}

// Required if you want to use transport delay (priority queue has to sort messages somehow)
inline bool operator < (const vp_cell& lhs, const vp_cell& rhs) { return true; }

// Required for printing the state of the cell
std::ostream &operator << (std::ostream &os, const vp_cell &x) {
	//note that breathing_counter is not included here as it is not useful for visualization and it will only slow the simulation to include it. Keep it this way unless needed for another reason
    //os << "<" << x.counter << "," << x.num_particles << "," << x.type << ">";
    os << "<" << x.counter << "," << x.prev_inhaled_particles << "," << x.inhaled_particles << "," << x.prev_num_particles << "," << x.num_particles << "," << x.prev_type << "," << x.type << ">";
    return os;
}

// Required for creating vp_cell objects from JSON file
void from_json(const json& j, vp_cell &s) {
    j.at("counter").get_to(s.counter);
    j.at("type").get_to(s.type);
    //j.at("breathing_counter").get_to(s.breathing_counter);
}

/************************************/
/******COMPLEX CONFIG STRUCTURE******/
/************************************/
struct source {
    int vp_production; //vp generated by one person
    float cell_size;
    int base; //vp base level
    int resp_time;
	int breathing_rate;
	int time_active; //amount of time in states spent at TABLE
	int start_time; //start state for TABLE occupation
    int infection_time;
    int infection_threshold;
    float flow_weight;

    // Each cell is 25cm x 25cm x 25cm = 15.626 Liters of air each
    // vp sources have their num_particles continually increased by default by 12.16 ppm every 5 seconds.
    source(): vp_production(11), cell_size(25), base(0), resp_time(1), breathing_rate(20), time_active(100), start_time(20), infection_time(100), infection_threshold(10), flow_weight(0.8) {}
    source(float ci, float cs, int b, int wc, int vc, int r, int br, int ta, int st, int ns, int nb, int md, int it, vector<int> fd, float fw): vp_production(ci), cell_size(cs), base(b), resp_time(r), breathing_rate(br), time_active(ta), start_time(st), infection_threshold(it), flow_weight(fw) {}
};
void from_json(const json& j, source &s) {
    j.at("vp_production").get_to(s.vp_production);
    j.at("cell_size").get_to(s.cell_size);
    j.at("resp_time").get_to(s.resp_time);
    j.at("breathing_rate").get_to(s.breathing_rate);
	j.at("time_active").get_to(s.time_active);
	j.at("start_time").get_to(s.start_time);
    j.at("infection_threshold").get_to(s.infection_threshold);
    j.at("flow_weight").get_to(s.flow_weight);

}

template <typename T>
class vp_res_cell : public grid_cell<T, vp_cell> {
public:
    using grid_cell<T, vp_cell, int>::simulation_clock;
    using grid_cell<T, vp_cell, int>::state;
    using grid_cell<T, vp_cell, int>::map;
    using grid_cell<T, vp_cell, int>::neighbors;

    using config_type = source;  // IMPORTANT FOR THE JSON   
    int num_particles_increase; //// vp sources have their num_particles continually increased
    int base; //vp base level 
    int resp_time; //Time used to calculate the num_particles inscrease /// set in JSON
	int breathing_rate; ///the interval between two consecutive breaths in seconds.//set intially from the JSON
	int time_active; ///time spent by the person at the TABLE ///set in JSON
	int start_time; ///start time for TABLE occupation ///set in JSON
    int infection_time;
    int infection_threshold;
    float flow_weight;
    int max_distance;
    cell_position pos;

 
    vp_res_cell() : grid_cell<T, vp_cell, int>() {
    }

    vp_res_cell(cell_position const &cell_id, cell_unordered<int> const &neighborhood, vp_cell initial_state,
        cell_map<vp_cell, int> const &map_in, std::string const &delayer_id, source config) :
            grid_cell<T, vp_cell>(cell_id, neighborhood, initial_state, map_in, delayer_id) {
                num_particles_increase = config.vp_production;
                base = config.base;
                resp_time = config.resp_time;
				breathing_rate = config.breathing_rate;
				time_active = config.time_active;
				start_time = config.start_time;
                infection_time = config.infection_time;
                infection_threshold = config.infection_threshold;
                flow_weight = config.flow_weight;
                pos = cell_id;

    }

   vp_cell local_computation() const override {
        vp_cell new_state = state.current_state;
        switch(new_state.type) {
            case IMPERMEABLE_STRUCTURE: 
                new_state.num_particles = 0;
                new_state.prev_type = IMPERMEABLE_STRUCTURE;
                break;
            case TABLE: {
                new_state.prev_type = TABLE;
                int num_neighbors = 0;
                int num_particles = 0;

                for(auto neighbors: state.neighbors_state) {
                    setDirection(new_state, neighbors);
                    loopNeighbors(num_neighbors, num_particles, new_state, neighbors);
                }
                computeParticles(new_state, num_neighbors, num_particles);
                break;
            }
            case VENTILATION:{
                new_state.num_particles = 0;
                new_state.prev_type = VENTILATION;
                for(auto neighbors: state.neighbors_state) {
                    /*
                    if( neighbors.second.num_particles < 0){
                        assert(false && "vp_cell num_particles cannot be negative");
                    } 
                    */
                    setDirection(new_state, neighbors);
                }
                break;
            }
            case AIR:{
                /*
                if((pos.at(1) >= 16 && pos.at(1) <= 22) || (pos.at(1) >= 45 && pos.at(1) <= 51)) {
                    cout << new_state.direction << pos << endl;
                }
                */
                new_state.prev_type = AIR;
                int num_neighbors = 0;
                int num_particles = 0;

                for(auto neighbors: state.neighbors_state) {
                    setDirection(new_state, neighbors);
                    loopNeighbors(num_neighbors, num_particles, new_state, neighbors);
                }
                computeParticles(new_state, num_neighbors, num_particles);
                break;
            }
            case CHAIR:{  
                new_state.prev_type = CHAIR;
                int num_neighbors = 0;
                int num_particles = 0;

                for(auto neighbors: state.neighbors_state) {
                    setDirection(new_state, neighbors);
                    loopNeighbors(num_neighbors, num_particles, new_state, neighbors);
                }
                computeParticles(new_state, num_neighbors, num_particles);

                if (new_state.counter == start_time){
                    vector<int> temp = {16,18};
                    vector<int> temp2 = {22,47};
                    if(pos == temp || pos == temp2) {
                        new_state.type = vp_SOURCE; 
                        new_state.breathing_counter = 0;
                    }
                    else {
                        int random = rand() % 5 + 1;
                        if(random == 3) {
                            int stayed = rand() % 3600 + 900;
                            new_state.type = vp_RECEIVER;
                            new_state.breathing_counter = 0;
                            new_state.time_stayed = stayed;
                        }
                    }
				}
                new_state.counter += 1;
                break;
            }
            case vp_RECEIVER: {
                new_state.prev_type = vp_RECEIVER;
                int num_neighbors = 0;
                int num_particles = 0;

                if(new_state.counter >= new_state.time_stayed) {
                    new_state.type = CHAIR;
                }
                if(new_state.inhaled_particles >= infection_threshold) {
                    new_state.type = vp_SOURCE;
                    break;
                }
                for(auto neighbors: state.neighbors_state) { 
                    setDirection(new_state, neighbors);
                    loopNeighbors(num_neighbors, num_particles, new_state, neighbors);
                }
                if(new_state.breathing_counter % breathing_rate == 0){
                    new_state.prev_inhaled_particles = new_state.inhaled_particles; 
                    new_state.inhaled_particles += new_state.num_particles;
                    new_state.num_particles = 0;
                }
                new_state.breathing_counter++;
                new_state.counter += 1;

                computeParticles(new_state, num_neighbors, num_particles);
                
                break;
            }
            case vp_SOURCE:{
                new_state.prev_type = vp_SOURCE;
                int num_neighbors = 0;
                int num_particles = 0;

                for(auto neighbors: state.neighbors_state) {
                    /*
                    if( neighbors.second.num_particles < 0){
                        assert(false && "vp_cell num_particles cannot be negative");
                    } 
                    */
                    setDirection(new_state, neighbors);
                    loopNeighbors(num_neighbors, num_particles, new_state, neighbors);
                }
                if(new_state.breathing_counter % breathing_rate == 0){
                    num_particles += num_particles_increase;
                }
                new_state.breathing_counter++;
                new_state.counter += 1;

                computeParticles(new_state, num_neighbors, num_particles);
    
                break;
            }
            default:{
                assert(false && "should never happen");
            }
        }
        return new_state;
    }

    void computeParticles(vp_cell& curr, int const& num_neighbors, int const& num_particles) const {
        curr.neighbor_portion = 0;
        vector<int> temp = {0,0};
        if(curr.direction != temp && !curr.edge) {
            curr.prev_num_particles = curr.num_particles;
            curr.num_particles = curr.remainder;
            curr.num_particles += num_particles;

            int flow = (curr.num_particles - curr.remainder) * flow_weight;
            curr.flow_portion = flow;
            curr.remainder += (curr.num_particles - flow - curr.remainder);

            if(curr.remainder % num_neighbors >= 0 && curr.remainder >= num_neighbors) {
                curr.neighbor_portion = curr.remainder/num_neighbors;
                curr.remainder = curr.remainder % num_neighbors;
            } 
        }   
        else {
            curr.prev_num_particles = curr.num_particles;
            curr.num_particles = curr.neighbor_portion + (curr.num_particles % num_neighbors);
            curr.num_particles += num_particles;

            if(curr.num_particles % num_neighbors >= 0 && curr.num_particles >= num_neighbors) {
                curr.neighbor_portion = curr.num_particles/num_neighbors;
                //curr.remainder = curr.num_particles % num_neighbors;
            } 
        }  
    }
    void setDirection(vp_cell& curr, pair<cell_position, vp_cell> const& nb) const {
        vector<int> N = {0,-1};
        vector<int> E = {1,0};
        vector<int> S = {0,1};
        vector<int> W = {-1,0};
        vector<int> Z = {0,0};
        if(curr.type == VENTILATION && nb.second.type == IMPERMEABLE_STRUCTURE) {
            if(curr.direction != Z) {
                return;
            }
            else if(this->map.relative(nb.first) == N) {
                curr.direction = S;
            }
            else if(this->map.relative(nb.first) == E) {
                curr.direction = W;
            }
            else if(this->map.relative(nb.first) == S) {
                curr.direction = N;
            }
            else if(this->map.relative(nb.first) == S) {
                curr.direction = E;
            }
        }
        else {
            if(curr.direction != Z) {
                return;
            }
            else if(this->map.relative(nb.first) == N && nb.second.direction == S) {
                curr.direction = S;
            }
            else if(this->map.relative(nb.first) == E && nb.second.direction == W) {
                curr.direction = W;
            }
            else if(this->map.relative(nb.first) == S && nb.second.direction == N) {
                curr.direction = N;
            }
            else if(this->map.relative(nb.first) == W && nb.second.direction == E) {
                curr.direction = E;
            }
        }
    }

    void loopNeighbors(int& num_neighbors, int& num_particles, vp_cell& curr, pair<cell_position, vp_cell> const& nb) const {
        if(nb.second.type != IMPERMEABLE_STRUCTURE){
            vector<int> temp = {0,0};
            vector<int> sum = {NULL, NULL};
            transform(curr.direction.begin(), curr.direction.end(), this->map.relative(nb.first).begin(), sum.begin(), plus<int>());
            if(curr.direction != temp && sum == temp) {
                num_particles += nb.second.flow_portion;
            }
            else {
                num_particles += nb.second.neighbor_portion;
            }
            num_neighbors++;
        }
        else {
            curr.edge = true;
        }
        return;
    }

    // It returns the delay to communicate cell's new state.
    T output_delay(vp_cell const &cell_state) const override {
		return resp_time;
    }

};

#endif //CADMIUM_CELLDEVS_vp_CELL_HPP