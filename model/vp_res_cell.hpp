/**
 * Copyright (c) 2020, Cristina Ruiz Martin
 * ARSLab - Carleton University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/**
* Model developed by Hoda Khalil in Cell-DEVS CD++
* Implemented in Cadmium-cell-DEVS by Cristina Ruiz Martin
*/

#ifndef CADMIUM_CELLDEVS_vp_CELL_HPP
#define CADMIUM_CELLDEVS_vp_CELL_HPP

#define MAX_BAG_SIZE 27

#include <cmath>
#include <nlohmann/json.hpp>
#include <cadmium/celldevs/cell/grid_cell.hpp>

using nlohmann::json;
using namespace cadmium::celldevs;
using namespace std;

/************************************/
/******COMPLEX STATE STRUCTURE*******/
/************************************/
enum CELL_TYPE {AIR=-100, vp_SOURCE=-200, IMPERMEABLE_STRUCTURE=-300, DOOR=-400, WINDOW=-500, VENTILATION=-600, TABLE=-700, vp_RECEIVER=-800};

struct vp;

struct vp_bag {
    vector<vp> particles;
    int num_particles;

    vp_bag() : num_particles(0), particles({}) {}
};

struct vp_cell {
    int counter;
    CELL_TYPE type;
    vector<vp_bag> bags;
    int breathing_counter=5;


    vp_cell() : counter(-1), type(AIR), breathing_counter(5), bags({})  {}  // a default constructor is required
    vp_cell(int i_counter, CELL_TYPE i_type, int i_breathing_counter, vector<vp_bag> i_bags) : counter(i_counter), type(i_type), breathing_counter(i_breathing_counter), bags(i_bags) {}

};

struct vp : vp_cell {
    int distance_travelled;
    int max_distance;

    vp() : distance_travelled(0), max_distance(100) {}
};

// Required for comparing states and detect any change
inline bool operator != (const vp_cell &x, const vp_cell &y) {
	//note that breathing_counter is not included here intentionally as it is onlu used to add the breathing factor
    return (x.counter != y.counter || x.type != y.type );
}
// Required if you want to use transport delay (priority queue has to sort messages somehow)
inline bool operator < (const vp_cell& lhs, const vp_cell& rhs){ return true; }

// Required for printing the state of the cell
std::ostream &operator << (std::ostream &os, const vp_cell &x) {
	//note that breathing_counter is not included here as it is not useful for visualization and it will only slow the simulation to include it. Keep it this way unless needed for another reason
    os << "<" << x.counter << "," << x.type << ">";
    return os;
}

// Required for creating vp_cell objects from JSON file
void from_json(const json& j, vp_cell &s) {
    j.at("counter").get_to(s.counter);
    j.at("type").get_to(s.type);
    //j.at("breathing_counter").get_to(s.breathing_counter);
}

/************************************/
/******COMPLEX CONFIG STRUCTURE******/
/************************************/
struct source {
    float vp_production; //vp generated by one person
    float cell_size;
    int base; //vp base level
    int resp_time;
	int breathing_rate;
	int time_active; //amount of time in states spent at TABLE
	int start_time; //start state for TABLE occupation
    cell_position pos = {11,3,4};

    // Each cell is 25cm x 25cm x 25cm = 15.626 Liters of air each
      // vp sources have their num_particles continually increased by default by 12.16 ppm every 5 seconds.
    source(): vp_production(2.75), cell_size(25), base(0), resp_time(1), breathing_rate(5), time_active(100), start_time(5) {}
    source(float ci, float cs, int b, int wc, int vc, int r, int br, int ta, int st, int ns): vp_production(ci), cell_size(cs), base(b), resp_time(r), breathing_rate(br), time_active(ta), start_time(st) {}
};
void from_json(const json& j, source &s) {
    j.at("vp_production").get_to(s.vp_production);
    j.at("cell_size").get_to(s.cell_size);
    j.at("resp_time").get_to(s.resp_time);
    j.at("breathing_rate").get_to(s.breathing_rate);
	j.at("time_active").get_to(s.time_active);
	j.at("start_time").get_to(s.start_time);
}

template <typename T>
class vp_res_cell : public grid_cell<T, vp_cell> {
public:
    using grid_cell<T, vp_cell, int>::simulation_clock;
    using grid_cell<T, vp_cell, int>::state;
    using grid_cell<T, vp_cell, int>::map;
    using grid_cell<T, vp_cell, int>::neighbors;

    using config_type = source;  // IMPORTANT FOR THE JSON   
    float num_particles_increase; //// vp sources have their num_particles continually increased
    int base; //vp base level 
    int resp_time; //Time used to calculate the num_particles inscrease /// set in JSON
	int breathing_rate; ///the interval between two consecutive breaths in seconds.//set intially from the JSON
	int time_active; ///time spent by the person at the TABLE ///set in JSON
	int start_time; ///start time for TABLE occupation ///set in JSON
    cell_position pos;

 
    vp_res_cell() : grid_cell<T, vp_cell, int>() {
    }

    vp_res_cell(cell_position const &cell_id, cell_unordered<int> const &neighborhood, vp_cell initial_state,
        cell_map<vp_cell, int> const &map_in, std::string const &delayer_id, source config) :
            grid_cell<T, vp_cell>(cell_id, neighborhood, initial_state, map_in, delayer_id) {
                num_particles_increase = 1000 * 10000 * config.vp_production/pow(config.cell_size,3);
                base = config.base;
                resp_time = config.resp_time;
				breathing_rate = config.breathing_rate;
				time_active = config.time_active;
				start_time = config.start_time;
                pos = cell_id;

    }
    /*
    void populate_bags(bag bags[]) {
        int size = 27;
        int num_part = (int) num_particles_increase/size;
        for (int i = 0; i < size; i++) {
            vp new_particle;
            bags[i].particles.push_back(new_particle);
            cout << bags[i].particles[i];
            bags[i].num_particles += num_part;
        }
    }
    */

    vp_cell local_computation() const override {
        //vp new_state = state.current_state;
        vp_cell new_state = state.current_state;
        switch(new_state.type){
            /*
            case IMPERMEABLE_STRUCTURE: 
                new_state.num_particles = 0;
                break;
            case DOOR:  
                new_state.num_particles = base;
                break;
            case WINDOW:
                new_state.num_particles = base;
                break;
            case VENTILATION:
                new_state.num_particles = base;
                break;
            case AIR:{
                int num_particles = 0;
                int num_neighbors = 0;
                for(auto neighbors: state.neighbors_state) {
                    if( neighbors.second.num_particles < 0){
                        assert(false && "vp num_particles cannot be negative");
                    }
                    if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
                        num_particles += neighbors.second.num_particles;
                        num_neighbors +=1;
                    }
                }
                new_state.num_particles = num_particles/num_neighbors;
                break;  
            }         
            */  
            case TABLE:{
                /*
                int num_particles = 0;
                int num_neighbors = 0;
                for(auto neighbors: state.neighbors_state) {
                    if( neighbors.second.num_particles < 0){
                        assert(false && "vp num_particles cannot be negative");
                    }
                    if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
                        num_particles += neighbors.second.num_particles;
                        num_neighbors +=1;
                    }
                }
                new_state.num_particles = num_particles/num_neighbors;
                */
                    
                if (state.current_state.counter <= start_time) { //TODO parameterize //done
                    new_state.counter += 1;
                }

                if (state.current_state.counter == start_time){
                    vector<int> temp = {11,3,4};
                    if(pos == temp) {
                        cout << "pos == source" << endl;
                        new_state.type = vp_SOURCE;
                        new_state.breathing_counter = 0;
                    }

				}
                break;
            }
            case vp_SOURCE:{
                /*
                for(auto neighbors: state.neighbors_state) {
                  if( neighbors.second.num_particles < 0){
                        assert(false && "vp num_particles cannot be negative");
                    }
                    if(neighbors.second.type != IMPERMEABLE_STRUCTURE){
                                              
                        //num_particles += neighbors.second.num_particles;
                        //num_neighbors +=1;

                    }
                }
                */
				//The num_particles increases every time an occupant breathes (the default breathing rate is every five seconds)
				if( (new_state.breathing_counter % breathing_rate) == 0) {
                    int particles_per_bag = 3; //(int) num_particles_increase/size;
                    for (int i = 0; i < MAX_BAG_SIZE; i++) {
                        vp_bag new_bag;
                        new_state.bags.push_back(new_bag);
                        new_bag.num_particles = particles_per_bag;
                        cout << "Bag[" << i + 1 << "]:" << endl;
                        cout << "-- Num particles: " << new_bag.num_particles << endl;
                        for (int j = 0; j < particles_per_bag; j++) {
                            vp new_particle;
                            new_state.bags[i].particles.push_back(new_particle);
                            cout << "   Particle[" << j + 1 << "]:" << endl;
                            cout << "   -- Counter: " << new_particle.counter << endl;
                            cout << "   -- Distance travelled: " << new_particle.distance_travelled << endl;
                            cout << "   -- Max distance: " << new_particle.max_distance << endl;
                            cout << "   -- Type: " << new_particle.type << endl;
                        }
                    }
				}
				new_state.breathing_counter++;
                new_state.counter += 1;
                break;
            }
            default:{
                break;
                //assert(false && "should never happen");
            }
        }
      
        return new_state;
        }
    

    
    // It returns the delay to communicate cell's new state.
    T output_delay(vp_cell const &cell_state) const override {
			return resp_time;
    }

};

#endif //CADMIUM_CELLDEVS_vp_CELL_HPP